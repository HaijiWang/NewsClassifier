package solr_classification.com;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;


public class IntermediateData implements Serializable {
	/**
	 * auto generated by eclipse.
	 */
	private static final long serialVersionUID = -420389048890617397L;

	/** �����. */
    public String[] classifications;
    
    /** ����X�����C�³��ֵ�����. */
	public HashMap[] filesOfXC;
	/** ���������µ��ļ���Ŀ. */
    public int[] filesOfC;
    /** ��Ŀ¼�µ��ļ�����. */
    public int files;
    
	/** ����X�����C�³��ֵ����� */
	public HashMap[] tokensOfXC;
    /** ���C�����е��ʵ�����. */
    public int[] tokensOfC;
    /** �������Ͽ��е��ʵ�����. */
    public int tokens;
    /** ����ѵ�����������ֵĵ���. */
    public HashSet<String> vocabulary;
    
    
    
    /** �ı��������ϵĸ�Ŀ¼. */
    private transient String dir;
    /** ���Ͽ��е��ı��ļ����ַ�����. */
    private transient String encoding;
    /** ���ķִ�. */
    //private transient ChineseSpliter textSpliter;
    
    public IntermediateData() {
    	vocabulary = new HashSet<String>();
    	//textSpliter = new ChineseSpliter();
    }
    
    /**
     * Ԥ���㣬�����м�������ŵ�������.
     * 
     * @param trainTextDir
     *            �Ѿ���������Ͽ⣬�ṹΪ 
     * trainnedTextDir 
     *            ��- ���1\
     *                    ��- �ļ�1.txt 
     *                    ��- �ļ�2.txt ...
     *            ��- ���2\
     *                    ��- �ļ�1.txt 
     *                    ��- �ļ�2.txt ...
     * @param txtEncoding
     *            ���Ͽ��е��ı��ļ�����
     */
    public final void generate(final String trainTextDir,
            final String txtEncoding, final String modelFile) {
        // һЩ��ʼ������
        dir = trainTextDir;
        if (txtEncoding == null) {
            encoding = "GBK"; // Ĭ���ı��ļ��ı���ΪGBK;
        } else {
            encoding = txtEncoding;
        }

        // ö��Ŀ¼����ø�������
        File tmpDir = new File(dir);
        if (!tmpDir.isDirectory()) {
            throw new IllegalArgumentException("ѵ�����Ͽ�����ʧ�ܣ� [" + dir
                    + "]");
        }
        classifications = tmpDir.list();
        
        filesOfC = new int[classifications.length];
        filesOfXC = new HashMap[classifications.length];
        tokensOfC = new int[classifications.length];
        tokensOfXC = new HashMap[classifications.length];
        for(int i = 0; i < classifications.length; i++) {
        	tokensOfXC[i] = new HashMap<String, Integer>();
        	filesOfXC[i] = new HashMap<String, Integer>();
        }
        
        // ������������ļ�����������
        for (int i = 0; i < classifications.length; i++) {
            int n = calcFileCountOfClassification(i);
            filesOfC[i] = n;
            files += n; // �����ļ�����������
        }
        
        // ��õ��ʱ�
        try {
			extractVocabulary();
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		// ���������µ�����������������
        try {
			calculate();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		// ��Ԥ����������д�뵽����
		try {
            ObjectOutputStream out = new ObjectOutputStream(
                    new FileOutputStream(modelFile));
            out.writeObject(this);
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    
    
    /** ��õ��ʱ�. 
     * @throws IOException ��ȡ���Ͽ����
     */
    private void extractVocabulary() throws IOException {
    	for (String c : classifications) {
            String[] filesPath = getFilesPath(dir, c);

            for (String file : filesPath) {
                String text = getText(file, encoding);

                String[] terms = null;
                // ���ķִʴ���(�ִʺ������ܻ�������ͣ�ôʣ�
                //terms = textSpliter.split(text, " ").split(" ");
                //terms = ChineseSpliter.dropStopWords(terms); // ȥ��ͣ�ôʣ�����Ӱ�����

                terms = Chinese_parser.participle(text);
                
                for (String term : terms) { 
                    vocabulary.add(term);
                }
            }
    	}
    }

    
    /**
     * ����ѵ���ı������ڸ��������µ�ѵ���ı���Ŀ.
     * 
     * @param c
     *            �����ķ���
     * @return ѵ���ı������ڸ��������µ�ѵ���ı���Ŀ
     */
    private int calcFileCountOfClassification(
            final int c) {
        File classDir = new File(dir + File.separator
                + classifications[c]);
        return classDir.list().length;
    }

    
    /**
     * ���� fileCountOfXC, fileCountOfC, fileCount, tokensOfXC, tokensOfC, tokens.
     * 
     * @throws IOException
     */
    private void calculate() throws IOException {
        for (int i = 0;i < classifications.length; i++) {
        	HashMap<String, Integer> tmpT = (HashMap<String, Integer>)tokensOfXC[i];
        	HashMap<String, Integer> tmpF = (HashMap<String, Integer>)filesOfXC[i];

            String[] filesPath = getFilesPath(dir, classifications[i]);
            
            filesOfC[i] = filesPath.length;
            files += filesOfC[i];

            HashSet<String> words = new HashSet<String>();
            for (String file : filesPath) {
            	words.clear();
                String text = getText(file, encoding);
                String[] terms = null;
                
                // ���ķִʴ���(�ִʺ������ܻ�������ͣ�ôʣ�
                //terms = textSpliter.split(text, " ").split(" ");
                //terms = ChineseSpliter.dropStopWords(terms); // ȥ��ͣ�ôʣ�����Ӱ�����

                terms = Chinese_parser.participle(text);
                
                for (String term : terms) { // ���㱾�����ÿ�����ʵĳ��ִ���
                	Integer value = tmpT.get(term);
                    if(value == null) {
                    	tmpT.put(term, new Integer(1));
                    } else {
                    	tmpT.put(term, value + 1);
                    }
                }
                
                // ��ʼ���� filesOfXC[i]
                for (String term : terms) { //ȥ���ظ�����
                    words.add(term);
                }
				for (Iterator<String> iter = words.iterator(); iter.hasNext();) {
					String key = iter.next();
					Integer value = tmpF.get(key);
					if (value == null) {
						tmpF.put(key, new Integer(1));
					} else {
						value++;
						tmpF.put(key, value);
					}
				}
            }

            // ����������е��ʵĳ������� nC
            for (Iterator<Entry<String, Integer>> iter = tmpT.entrySet()
                    .iterator(); iter.hasNext();) {
                Entry<String, Integer> entry = iter.next();

                tokensOfC[i] += entry.getValue().intValue();
            }
            
            tokens += tokensOfC[i]; // ���е��ʳ�������
        }
    }
    
    
    /**
     * ����ѵ���ı���𷵻��������µ�����ѵ���ı�·��(full path).
     * 
     * @param dirStr �ѷ�����ı���Ŀ¼��ĩβ����б��
     * @param classification
     *            �����ķ���
     * @return ���������������ļ���·����full path��
     */
    public static String[] getFilesPath(final String dirStr, final String classification) {
        File classDir = new File(dirStr + File.separator
                + classification);
        String[] ret = classDir.list();
        for (int i = 0; i < ret.length; i++) {
            ret[i] = dirStr + File.separator
                    + classification + File.separator + ret[i];
        }
        return ret;
    }


    /**
     * ���ظ���·�����ı��ļ�����.
     * 
     * @param filePath
     *            �������ı��ļ�·��
     * @param encoding �ı��ļ��ı���
     * @return �ı�����
     * @throws java.io.IOException
     *             �ļ��Ҳ�����IO����
     */
    public static String getText(final String filePath, final String encoding)
            throws IOException {

        InputStreamReader isReader = new InputStreamReader(new FileInputStream(
                filePath), encoding);
        BufferedReader reader = new BufferedReader(isReader);
        String aLine;
        StringBuilder sb = new StringBuilder();

        while ((aLine = reader.readLine()) != null) {
            sb.append(aLine + " ");
        }
        isReader.close();
        reader.close();
        return sb.toString();
    }
    
    /** ��ӡ�����в����Ľ�����Ϣ. */
    private static void usage() {
        System.err.println("usage:\t  <���Ͽ�Ŀ¼> <���Ͽ��ı�����> <�м��ļ�>");
    }
    
    /**
     * ʹ�÷�����IntermediateData d:\SogouC.mini\Sample\ gbk d:\mini.db
     * @param args
     */
    public static void main(String args[]) {
    	if(args.length < 3) {
    		usage();
    		return;
    	}
    	System.out.println("�м�����������......");
    	IntermediateData tdm = new IntermediateData();
    	tdm.generate(args[0], args[1], args[2]);
    	System.out.println("�м��������ɣ�");
    }
}
